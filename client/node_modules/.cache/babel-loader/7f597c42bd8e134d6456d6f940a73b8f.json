{"ast":null,"code":"import { createAsyncThunk, createSlice } from \"@reduxjs/toolkit\";\nconst initialState = {\n  user: null,\n  message: \"\",\n  token: null,\n  status: \"idle\"\n}; // The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\n// export const incrementAsync = createAsyncThunk(\n//   'counter/fetchCount',\n//   async (amount) => {\n//     const response = await fetchCount(amount);\n//     // The value we return becomes the `fulfilled` action payload\n//     return response.data;\n//   }\n// );\n\nexport const login = createAsyncThunk(\"auth/fetchUser\", async creds => {\n  console.log(JSON.stringify(creds));\n  const options = {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(creds)\n  };\n  const response = await fetch(\"http://127.0.0.1:8080/api/auth/signin\", options);\n  const data = await response.json();\n  return data;\n});\nexport const signup = createAsyncThunk(\"auth/addUser\", async creds => {\n  console.log(JSON.stringify(creds));\n  const options = {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(creds)\n  };\n  const response = await fetch(\"http://127.0.0.1:8080/api/auth/signup\", options);\n  const data = await response.json();\n  return data;\n});\nexport const userSlice = createSlice({\n  name: \"user\",\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    logout: state => {\n      // Redux Toolkit allows us to write \"mutating\" logic in reducers. It\n      // doesn't actually mutate the state because it uses the Immer library,\n      // which detects changes to a \"draft state\" and produces a brand new\n      // immutable state based off those changes\n      state.user = null;\n      state.token = null;\n    }\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: builder => {\n    builder.addCase(login.pending, state => {\n      state.status = \"loading\";\n    }).addCase(login.fulfilled, (state, action) => {\n      state.status = \"idle\";\n      console.log(action.payload);\n      state.user = action.payload;\n    }).addCase(signup.pending, state => {\n      state.status = \"loading\";\n    }).addCase(signup.fulfilled, (state, action) => {\n      state.status = \"idle\";\n      console.log(action.meta);\n      state.user = action.meta;\n    });\n  }\n});\nexport const {\n  logout\n} = userSlice.actions; // The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\n// export const selectCount = (state) => state.counter.value;\n// We can also write thunks by hand, which may contain both sync and async logic.\n// Here's an example of conditionally dispatching actions based on current state.\n// export const incrementIfOdd = (amount) => (dispatch, getState) => {\n//   const currentValue = selectCount(getState());\n//   if (currentValue % 2 === 1) {\n//     dispatch(incrementByAmount(amount));\n//   }\n// };\n\nexport default userSlice.reducer;","map":{"version":3,"names":["createAsyncThunk","createSlice","initialState","user","message","token","status","login","creds","console","log","JSON","stringify","options","method","headers","body","response","fetch","data","json","signup","userSlice","name","reducers","logout","state","extraReducers","builder","addCase","pending","fulfilled","action","payload","meta","actions","reducer"],"sources":["/Users/mitchelleglon/Portfolio/movie-app/client/src/features/user/userSlice.js"],"sourcesContent":["import { createAsyncThunk, createSlice } from \"@reduxjs/toolkit\";\n\nconst initialState = {\n  user: null,\n  message: \"\",\n  token: null,\n  status: \"idle\",\n};\n\n// The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\n\n// export const incrementAsync = createAsyncThunk(\n//   'counter/fetchCount',\n//   async (amount) => {\n//     const response = await fetchCount(amount);\n//     // The value we return becomes the `fulfilled` action payload\n//     return response.data;\n//   }\n// );\n\nexport const login = createAsyncThunk(\"auth/fetchUser\", async (creds) => {\n  console.log(JSON.stringify(creds));\n  const options = {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(creds),\n  };\n  const response = await fetch(\n    \"http://127.0.0.1:8080/api/auth/signin\",\n    options\n  );\n  const data = await response.json();\n  return data;\n});\n\nexport const signup = createAsyncThunk(\"auth/addUser\", async (creds) => {\n  console.log(JSON.stringify(creds));\n  const options = {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(creds),\n  };\n  const response = await fetch(\n    \"http://127.0.0.1:8080/api/auth/signup\",\n    options\n  );\n  const data = await response.json();\n  return data;\n});\n\nexport const userSlice = createSlice({\n  name: \"user\",\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    logout: (state) => {\n      // Redux Toolkit allows us to write \"mutating\" logic in reducers. It\n      // doesn't actually mutate the state because it uses the Immer library,\n      // which detects changes to a \"draft state\" and produces a brand new\n      // immutable state based off those changes\n      state.user = null;\n      state.token = null;\n    },\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: (builder) => {\n    builder\n      .addCase(login.pending, (state) => {\n        state.status = \"loading\";\n      })\n      .addCase(login.fulfilled, (state, action) => {\n        state.status = \"idle\";\n        console.log(action.payload);\n        state.user = action.payload;\n      })\n      .addCase(signup.pending, (state) => {\n        state.status = \"loading\";\n      })\n      .addCase(signup.fulfilled, (state, action) => {\n        state.status = \"idle\";\n        console.log(action.meta);\n        state.user = action.meta;\n      });\n  },\n});\n\nexport const { logout } = userSlice.actions;\n\n// The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\n// export const selectCount = (state) => state.counter.value;\n\n// We can also write thunks by hand, which may contain both sync and async logic.\n// Here's an example of conditionally dispatching actions based on current state.\n// export const incrementIfOdd = (amount) => (dispatch, getState) => {\n//   const currentValue = selectCount(getState());\n//   if (currentValue % 2 === 1) {\n//     dispatch(incrementByAmount(amount));\n//   }\n// };\n\nexport default userSlice.reducer;\n"],"mappings":"AAAA,SAASA,gBAAT,EAA2BC,WAA3B,QAA8C,kBAA9C;AAEA,MAAMC,YAAY,GAAG;EACnBC,IAAI,EAAE,IADa;EAEnBC,OAAO,EAAE,EAFU;EAGnBC,KAAK,EAAE,IAHY;EAInBC,MAAM,EAAE;AAJW,CAArB,C,CAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMC,KAAK,GAAGP,gBAAgB,CAAC,gBAAD,EAAmB,MAAOQ,KAAP,IAAiB;EACvEC,OAAO,CAACC,GAAR,CAAYC,IAAI,CAACC,SAAL,CAAeJ,KAAf,CAAZ;EACA,MAAMK,OAAO,GAAG;IACdC,MAAM,EAAE,MADM;IAEdC,OAAO,EAAE;MAAE,gBAAgB;IAAlB,CAFK;IAGdC,IAAI,EAAEL,IAAI,CAACC,SAAL,CAAeJ,KAAf;EAHQ,CAAhB;EAKA,MAAMS,QAAQ,GAAG,MAAMC,KAAK,CAC1B,uCAD0B,EAE1BL,OAF0B,CAA5B;EAIA,MAAMM,IAAI,GAAG,MAAMF,QAAQ,CAACG,IAAT,EAAnB;EACA,OAAOD,IAAP;AACD,CAboC,CAA9B;AAeP,OAAO,MAAME,MAAM,GAAGrB,gBAAgB,CAAC,cAAD,EAAiB,MAAOQ,KAAP,IAAiB;EACtEC,OAAO,CAACC,GAAR,CAAYC,IAAI,CAACC,SAAL,CAAeJ,KAAf,CAAZ;EACA,MAAMK,OAAO,GAAG;IACdC,MAAM,EAAE,MADM;IAEdC,OAAO,EAAE;MAAE,gBAAgB;IAAlB,CAFK;IAGdC,IAAI,EAAEL,IAAI,CAACC,SAAL,CAAeJ,KAAf;EAHQ,CAAhB;EAKA,MAAMS,QAAQ,GAAG,MAAMC,KAAK,CAC1B,uCAD0B,EAE1BL,OAF0B,CAA5B;EAIA,MAAMM,IAAI,GAAG,MAAMF,QAAQ,CAACG,IAAT,EAAnB;EACA,OAAOD,IAAP;AACD,CAbqC,CAA/B;AAeP,OAAO,MAAMG,SAAS,GAAGrB,WAAW,CAAC;EACnCsB,IAAI,EAAE,MAD6B;EAEnCrB,YAFmC;EAGnC;EACAsB,QAAQ,EAAE;IACRC,MAAM,EAAGC,KAAD,IAAW;MACjB;MACA;MACA;MACA;MACAA,KAAK,CAACvB,IAAN,GAAa,IAAb;MACAuB,KAAK,CAACrB,KAAN,GAAc,IAAd;IACD;EARO,CAJyB;EAcnC;EACA;EACAsB,aAAa,EAAGC,OAAD,IAAa;IAC1BA,OAAO,CACJC,OADH,CACWtB,KAAK,CAACuB,OADjB,EAC2BJ,KAAD,IAAW;MACjCA,KAAK,CAACpB,MAAN,GAAe,SAAf;IACD,CAHH,EAIGuB,OAJH,CAIWtB,KAAK,CAACwB,SAJjB,EAI4B,CAACL,KAAD,EAAQM,MAAR,KAAmB;MAC3CN,KAAK,CAACpB,MAAN,GAAe,MAAf;MACAG,OAAO,CAACC,GAAR,CAAYsB,MAAM,CAACC,OAAnB;MACAP,KAAK,CAACvB,IAAN,GAAa6B,MAAM,CAACC,OAApB;IACD,CARH,EASGJ,OATH,CASWR,MAAM,CAACS,OATlB,EAS4BJ,KAAD,IAAW;MAClCA,KAAK,CAACpB,MAAN,GAAe,SAAf;IACD,CAXH,EAYGuB,OAZH,CAYWR,MAAM,CAACU,SAZlB,EAY6B,CAACL,KAAD,EAAQM,MAAR,KAAmB;MAC5CN,KAAK,CAACpB,MAAN,GAAe,MAAf;MACAG,OAAO,CAACC,GAAR,CAAYsB,MAAM,CAACE,IAAnB;MACAR,KAAK,CAACvB,IAAN,GAAa6B,MAAM,CAACE,IAApB;IACD,CAhBH;EAiBD;AAlCkC,CAAD,CAA7B;AAqCP,OAAO,MAAM;EAAET;AAAF,IAAaH,SAAS,CAACa,OAA7B,C,CAEP;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAeb,SAAS,CAACc,OAAzB"},"metadata":{},"sourceType":"module"}