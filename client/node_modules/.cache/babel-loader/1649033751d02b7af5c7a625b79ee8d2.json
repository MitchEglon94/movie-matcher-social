{"ast":null,"code":"import { createAsyncThunk, createSlice } from \"@reduxjs/toolkit\";\nconst initialState = {\n  user: null,\n  token: null,\n  status: \"idle\"\n}; // The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\n// export const incrementAsync = createAsyncThunk(\n//   'counter/fetchCount',\n//   async (amount) => {\n//     const response = await fetchCount(amount);\n//     // The value we return becomes the `fulfilled` action payload\n//     return response.data;\n//   }\n// );\n\nexport const login = createAsyncThunk(\"auth/fetchUser\", async creds => {\n  console.log(creds);\n  const options = {\n    method: \"POST\",\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(creds)\n  };\n  const response = await fetch(\"http://127.0.0.1:8080/api/auth/signin\", options);\n  return response;\n});\nexport const userSlice = createSlice({\n  name: \"user\",\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    logout: state => {\n      // Redux Toolkit allows us to write \"mutating\" logic in reducers. It\n      // doesn't actually mutate the state because it uses the Immer library,\n      // which detects changes to a \"draft state\" and produces a brand new\n      // immutable state based off those changes\n      state.user = null;\n      state.token = null;\n    }\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: builder => {\n    builder.addCase(login.pending, state => {\n      state.status = \"loading\";\n    }).addCase(login.fulfilled, (state, action) => {\n      state.status = \"idle\";\n      state.user = action.payload;\n    });\n  }\n});\nexport const {\n  logout\n} = userSlice.actions; // The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\n// export const selectCount = (state) => state.counter.value;\n// We can also write thunks by hand, which may contain both sync and async logic.\n// Here's an example of conditionally dispatching actions based on current state.\n// export const incrementIfOdd = (amount) => (dispatch, getState) => {\n//   const currentValue = selectCount(getState());\n//   if (currentValue % 2 === 1) {\n//     dispatch(incrementByAmount(amount));\n//   }\n// };\n\nexport default userSlice.reducer;","map":{"version":3,"names":["createAsyncThunk","createSlice","initialState","user","token","status","login","creds","console","log","options","method","mode","headers","body","JSON","stringify","response","fetch","userSlice","name","reducers","logout","state","extraReducers","builder","addCase","pending","fulfilled","action","payload","actions","reducer"],"sources":["/Users/mitchelleglon/Portfolio/movie-app/client/src/features/user/userSlice.js"],"sourcesContent":["import { createAsyncThunk, createSlice } from \"@reduxjs/toolkit\";\n\nconst initialState = {\n  user: null,\n  token: null,\n  status: \"idle\",\n};\n\n// The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\n\n// export const incrementAsync = createAsyncThunk(\n//   'counter/fetchCount',\n//   async (amount) => {\n//     const response = await fetchCount(amount);\n//     // The value we return becomes the `fulfilled` action payload\n//     return response.data;\n//   }\n// );\n\nexport const login = createAsyncThunk(\"auth/fetchUser\", async (creds) => {\n  console.log(creds);\n  const options = {\n    method: \"POST\",\n    mode: \"cors\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(creds),\n  };\n  const response = await fetch(\n    \"http://127.0.0.1:8080/api/auth/signin\",\n    options\n  );\n  return response;\n});\n\nexport const userSlice = createSlice({\n  name: \"user\",\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    logout: (state) => {\n      // Redux Toolkit allows us to write \"mutating\" logic in reducers. It\n      // doesn't actually mutate the state because it uses the Immer library,\n      // which detects changes to a \"draft state\" and produces a brand new\n      // immutable state based off those changes\n      state.user = null;\n      state.token = null;\n    },\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: (builder) => {\n    builder\n      .addCase(login.pending, (state) => {\n        state.status = \"loading\";\n      })\n      .addCase(login.fulfilled, (state, action) => {\n        state.status = \"idle\";\n        state.user = action.payload;\n      });\n  },\n});\n\nexport const { logout } = userSlice.actions;\n\n// The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\n// export const selectCount = (state) => state.counter.value;\n\n// We can also write thunks by hand, which may contain both sync and async logic.\n// Here's an example of conditionally dispatching actions based on current state.\n// export const incrementIfOdd = (amount) => (dispatch, getState) => {\n//   const currentValue = selectCount(getState());\n//   if (currentValue % 2 === 1) {\n//     dispatch(incrementByAmount(amount));\n//   }\n// };\n\nexport default userSlice.reducer;\n"],"mappings":"AAAA,SAASA,gBAAT,EAA2BC,WAA3B,QAA8C,kBAA9C;AAEA,MAAMC,YAAY,GAAG;EACnBC,IAAI,EAAE,IADa;EAEnBC,KAAK,EAAE,IAFY;EAGnBC,MAAM,EAAE;AAHW,CAArB,C,CAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMC,KAAK,GAAGN,gBAAgB,CAAC,gBAAD,EAAmB,MAAOO,KAAP,IAAiB;EACvEC,OAAO,CAACC,GAAR,CAAYF,KAAZ;EACA,MAAMG,OAAO,GAAG;IACdC,MAAM,EAAE,MADM;IAEdC,IAAI,EAAE,MAFQ;IAGdC,OAAO,EAAE;MAAE,gBAAgB;IAAlB,CAHK;IAIdC,IAAI,EAAEC,IAAI,CAACC,SAAL,CAAeT,KAAf;EAJQ,CAAhB;EAMA,MAAMU,QAAQ,GAAG,MAAMC,KAAK,CAC1B,uCAD0B,EAE1BR,OAF0B,CAA5B;EAIA,OAAOO,QAAP;AACD,CAboC,CAA9B;AAeP,OAAO,MAAME,SAAS,GAAGlB,WAAW,CAAC;EACnCmB,IAAI,EAAE,MAD6B;EAEnClB,YAFmC;EAGnC;EACAmB,QAAQ,EAAE;IACRC,MAAM,EAAGC,KAAD,IAAW;MACjB;MACA;MACA;MACA;MACAA,KAAK,CAACpB,IAAN,GAAa,IAAb;MACAoB,KAAK,CAACnB,KAAN,GAAc,IAAd;IACD;EARO,CAJyB;EAcnC;EACA;EACAoB,aAAa,EAAGC,OAAD,IAAa;IAC1BA,OAAO,CACJC,OADH,CACWpB,KAAK,CAACqB,OADjB,EAC2BJ,KAAD,IAAW;MACjCA,KAAK,CAAClB,MAAN,GAAe,SAAf;IACD,CAHH,EAIGqB,OAJH,CAIWpB,KAAK,CAACsB,SAJjB,EAI4B,CAACL,KAAD,EAAQM,MAAR,KAAmB;MAC3CN,KAAK,CAAClB,MAAN,GAAe,MAAf;MACAkB,KAAK,CAACpB,IAAN,GAAa0B,MAAM,CAACC,OAApB;IACD,CAPH;EAQD;AAzBkC,CAAD,CAA7B;AA4BP,OAAO,MAAM;EAAER;AAAF,IAAaH,SAAS,CAACY,OAA7B,C,CAEP;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAeZ,SAAS,CAACa,OAAzB"},"metadata":{},"sourceType":"module"}