'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('../utils/click/isClickableInput.js');
require('../utils/dataTransfer/Clipboard.js');
require('../utils/edit/maxLength.js');
require('../utils/edit/isEditable.js');
require('@testing-library/dom');
require('@testing-library/dom/dist/helpers.js');
require('../utils/keyDef/readNextDescriptor.js');
require('../utils/misc/level.js');
require('../options.js');
require('../event/eventMap.js');
require('../event/behavior/click.js');
require('../event/behavior/cut.js');
require('../event/behavior/keydown.js');
require('../event/behavior/keypress.js');
require('../event/behavior/keyup.js');
require('../event/behavior/paste.js');
var interceptor = require('./interceptor.js');
var value = require('./value.js');

const UISelection = Symbol('Displayed selection in UI');
function prepareSelectionInterceptor(element) {
    interceptor.prepareInterceptor(element, 'setSelectionRange', function interceptorImpl(start, ...others) {
        const isUI = start && typeof start === 'object' && start[UISelection];
        if (!isUI) {
            this[UISelection] = undefined;
        }
        return {
            applyNative: !!isUI,
            realArgs: [
                Number(start),
                ...others
            ]
        };
    });
    interceptor.prepareInterceptor(element, 'selectionStart', function interceptorImpl(v) {
        this[UISelection] = undefined;
        return {
            realArgs: v
        };
    });
    interceptor.prepareInterceptor(element, 'selectionEnd', function interceptorImpl(v) {
        this[UISelection] = undefined;
        return {
            realArgs: v
        };
    });
    interceptor.prepareInterceptor(element, 'select', function interceptorImpl() {
        this[UISelection] = {
            anchorOffset: 0,
            focusOffset: value.getUIValue(element).length
        };
        return {
            realArgs: []
        };
    });
}
function setUISelection(element, { focusOffset: focusOffsetParam , anchorOffset: anchorOffsetParam = focusOffsetParam  }, mode = 'replace') {
    const valueLength = value.getUIValue(element).length;
    const sanitizeOffset = (o)=>Math.max(0, Math.min(valueLength, o));
    const anchorOffset = mode === 'replace' || element[UISelection] === undefined ? sanitizeOffset(anchorOffsetParam) : element[UISelection].anchorOffset;
    const focusOffset = sanitizeOffset(focusOffsetParam);
    const startOffset = Math.min(anchorOffset, focusOffset);
    const endOffset = Math.max(anchorOffset, focusOffset);
    element[UISelection] = {
        anchorOffset,
        focusOffset
    };
    if (element.selectionStart === startOffset && element.selectionEnd === endOffset) {
        return;
    }
    // eslint-disable-next-line no-new-wrappers
    const startObj = new Number(startOffset);
    startObj[UISelection] = UISelection;
    try {
        element.setSelectionRange(startObj, endOffset);
    } catch  {
    // DOMException for invalid state is expected when calling this
    // on an element without support for setSelectionRange
    }
}
function getUISelection(element) {
    var _selectionStart, _selectionEnd, _UISelection;
    const sel = (_UISelection = element[UISelection]) !== null && _UISelection !== void 0 ? _UISelection : {
        anchorOffset: (_selectionStart = element.selectionStart) !== null && _selectionStart !== void 0 ? _selectionStart : 0,
        focusOffset: (_selectionEnd = element.selectionEnd) !== null && _selectionEnd !== void 0 ? _selectionEnd : 0
    };
    return {
        ...sel,
        startOffset: Math.min(sel.anchorOffset, sel.focusOffset),
        endOffset: Math.max(sel.anchorOffset, sel.focusOffset)
    };
}
function hasUISelection(element) {
    return !!element[UISelection];
}
/** Flag the IDL selection as clean. This does not change the selection. */ function setUISelectionClean(element) {
    element[UISelection] = undefined;
}

exports.getUISelection = getUISelection;
exports.hasUISelection = hasUISelection;
exports.prepareSelectionInterceptor = prepareSelectionInterceptor;
exports.setUISelection = setUISelection;
exports.setUISelectionClean = setUISelectionClean;
