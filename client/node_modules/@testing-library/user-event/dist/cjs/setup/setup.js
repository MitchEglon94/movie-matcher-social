'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var index$1 = require('../document/index.js');
var index$2 = require('../event/index.js');
var options = require('../options.js');
require('../utils/click/isClickableInput.js');
var Clipboard = require('../utils/dataTransfer/Clipboard.js');
require('../utils/edit/maxLength.js');
require('../utils/edit/isEditable.js');
require('@testing-library/dom');
require('@testing-library/dom/dist/helpers.js');
require('../utils/keyDef/readNextDescriptor.js');
var getDocumentFromNode = require('../utils/misc/getDocumentFromNode.js');
var level = require('../utils/misc/level.js');
var wait = require('../utils/misc/wait.js');
var index = require('../system/index.js');
var config = require('./config.js');
var api = require('./api.js');
var wrapAsync = require('./wrapAsync.js');

function createConfig(options$1 = {}, defaults = options.defaultOptionsSetup, node) {
    const document = getDocument(options$1, node, defaults);
    var _system;
    return {
        ...defaults,
        ...options$1,
        document,
        system: (_system = options$1.system) !== null && _system !== void 0 ? _system : new index.System()
    };
}
/**
 * Start a "session" with userEvent.
 * All APIs returned by this function share an input device state and a default configuration.
 */ function setupMain(options = {}) {
    const config = createConfig(options);
    index$1.prepareDocument(config.document);
    var _defaultView;
    const view = (_defaultView = config.document.defaultView) !== null && _defaultView !== void 0 ? _defaultView : /* istanbul ignore next */ globalThis.window;
    Clipboard.attachClipboardStubToView(view);
    return doSetup(config);
}
/**
 * Setup in direct call per `userEvent.anyApi()`
 */ function setupDirect({ keyboardState , pointerState , ...options$1 } = {}, node) {
    const config = createConfig({
        ...options$1,
        system: pointerState !== null && pointerState !== void 0 ? pointerState : keyboardState
    }, options.defaultOptionsDirect, node);
    index$1.prepareDocument(config.document);
    return {
        config,
        api: doSetup(config)
    };
}
/**
 * Create a set of callbacks with different default settings but the same state.
 */ function setupSub(options) {
    return doSetup({
        ...this[config.Config],
        ...options
    });
}
function wrapAndBindImpl(instance, impl) {
    function method(...args) {
        level.setLevelRef(instance[config.Config], level.ApiLevel.Call);
        return wrapAsync.wrapAsync(()=>impl.apply(instance, args).then(async (ret)=>{
                await wait.wait(instance[config.Config]);
                return ret;
            }));
    }
    Object.defineProperty(method, 'name', {
        get: ()=>impl.name
    });
    return method;
}
function doSetup(config$1) {
    const instance = {
        [config.Config]: config$1,
        dispatchUIEvent: index$2.bindDispatchUIEvent(config$1),
        ...api
    };
    return {
        ...Object.fromEntries(Object.entries(api).map(([name, api])=>[
                name,
                wrapAndBindImpl(instance, api), 
            ])),
        setup: setupSub.bind(instance)
    };
}
function getDocument(options, node, defaults) {
    var _document, ref;
    return (ref = (_document = options.document) !== null && _document !== void 0 ? _document : node && getDocumentFromNode.getDocumentFromNode(node)) !== null && ref !== void 0 ? ref : defaults.document;
}

exports.createConfig = createConfig;
exports.setupDirect = setupDirect;
exports.setupMain = setupMain;
exports.setupSub = setupSub;
