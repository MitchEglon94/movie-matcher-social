'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var index = require('../../event/index.js');
require('../../utils/click/isClickableInput.js');
require('../../utils/dataTransfer/Clipboard.js');
require('../../utils/edit/maxLength.js');
require('../../utils/edit/isEditable.js');
require('@testing-library/dom');
require('@testing-library/dom/dist/helpers.js');
require('../../utils/keyDef/readNextDescriptor.js');
var getTreeDiff = require('../../utils/misc/getTreeDiff.js');
require('../../utils/misc/level.js');
var cssPointerEvents = require('../../utils/pointer/cssPointerEvents.js');
var index$1 = require('./index.js');

class Pointer {
    init(config, position) {
        this.position = position;
        const target = this.getTarget(config);
        const [, enter] = getTreeDiff.getTreeDiff(null, target);
        const init = this.getEventInit();
        cssPointerEvents.assertPointerEvents(config, target);
        index.dispatchUIEvent(config, target, 'pointerover', init);
        enter.forEach((el)=>index.dispatchUIEvent(config, el, 'pointerenter', init));
        return this;
    }
    move(config, position) {
        const prevPosition = this.position;
        const prevTarget = this.getTarget(config);
        this.position = position;
        if (!index$1.isDifferentPointerPosition(prevPosition, position)) {
            return;
        }
        const nextTarget = this.getTarget(config);
        const init = this.getEventInit();
        const [leave, enter] = getTreeDiff.getTreeDiff(prevTarget, nextTarget);
        return {
            leave: ()=>{
                if (cssPointerEvents.hasPointerEvents(config, prevTarget)) {
                    if (prevTarget !== nextTarget) {
                        index.dispatchUIEvent(config, prevTarget, 'pointerout', init);
                        leave.forEach((el)=>index.dispatchUIEvent(config, el, 'pointerleave', init));
                    }
                }
            },
            enter: ()=>{
                cssPointerEvents.assertPointerEvents(config, nextTarget);
                if (prevTarget !== nextTarget) {
                    index.dispatchUIEvent(config, nextTarget, 'pointerover', init);
                    enter.forEach((el)=>index.dispatchUIEvent(config, el, 'pointerenter', init));
                }
            },
            move: ()=>{
                index.dispatchUIEvent(config, nextTarget, 'pointermove', init);
            }
        };
    }
    down(config, _keyDef) {
        if (this.isDown) {
            return;
        }
        const target = this.getTarget(config);
        cssPointerEvents.assertPointerEvents(config, target);
        this.isDown = true;
        this.isPrevented = !index.dispatchUIEvent(config, target, 'pointerdown', this.getEventInit());
    }
    up(config, _keyDef) {
        if (!this.isDown) {
            return;
        }
        const target = this.getTarget(config);
        cssPointerEvents.assertPointerEvents(config, target);
        this.isDown = false;
        index.dispatchUIEvent(config, target, 'pointerup', this.getEventInit());
    }
    release(config) {
        const target = this.getTarget(config);
        const [leave] = getTreeDiff.getTreeDiff(target, null);
        const init = this.getEventInit();
        // Currently there is no PointerEventsCheckLevel that would
        // make this check not use the *asserted* cached value from `up`.
        /* istanbul ignore else */ if (cssPointerEvents.hasPointerEvents(config, target)) {
            index.dispatchUIEvent(config, target, 'pointerout', init);
            leave.forEach((el)=>index.dispatchUIEvent(config, el, 'pointerleave', init));
        }
        this.isCancelled = true;
    }
    getTarget(config) {
        var _target;
        return (_target = this.position.target) !== null && _target !== void 0 ? _target : config.document.body;
    }
    getEventInit() {
        return {
            ...this.position.coords,
            pointerId: this.pointerId,
            pointerType: this.pointerType,
            isPrimary: this.isPrimary
        };
    }
    constructor({ pointerId , pointerType , isPrimary  }){
        this.isMultitouch = false;
        this.isCancelled = false;
        this.isDown = false;
        this.isPrevented = false;
        this.position = {};
        this.pointerId = pointerId;
        this.pointerType = pointerType;
        this.isPrimary = isPrimary;
        this.isMultitouch = !isPrimary;
    }
}

exports.Pointer = Pointer;
