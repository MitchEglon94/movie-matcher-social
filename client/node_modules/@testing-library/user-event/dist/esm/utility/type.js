import '../utils/click/isClickableInput.js';
import '../utils/dataTransfer/Clipboard.js';
import '../event/eventMap.js';
import '../event/behavior/click.js';
import '../event/behavior/cut.js';
import '../event/behavior/keydown.js';
import '../event/behavior/keypress.js';
import '../event/behavior/keyup.js';
import '../event/behavior/paste.js';
import '@testing-library/dom';
import '../utils/edit/maxLength.js';
import '../utils/edit/isEditable.js';
import { setSelectionRange } from '../utils/focus/selection.js';
import '@testing-library/dom/dist/helpers.js';
import '../utils/keyDef/readNextDescriptor.js';
import '../utils/misc/level.js';
import '../options.js';
import { releaseAllKeys } from '../keyboard/index.js';
import { Config } from '../setup/config.js';

async function type(element, text, { skipClick =this[Config].skipClick , skipAutoClose =this[Config].skipAutoClose , initialSelectionStart , initialSelectionEnd  } = {}) {
    // TODO: properly type guard
    // we use this workaround for now to prevent changing behavior
    if (element.disabled) return;
    if (!skipClick) {
        await this.click(element);
    }
    if (initialSelectionStart !== undefined) {
        setSelectionRange(element, initialSelectionStart, initialSelectionEnd !== null && initialSelectionEnd !== void 0 ? initialSelectionEnd : initialSelectionStart);
    }
    await this.keyboard(text);
    if (!skipAutoClose) {
        await releaseAllKeys(this[Config]);
    }
}

export { type };
