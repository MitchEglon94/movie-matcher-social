import { dispatchUIEvent } from '../../event/index.js';
import '../../utils/click/isClickableInput.js';
import '../../utils/dataTransfer/Clipboard.js';
import '../../utils/edit/maxLength.js';
import '../../utils/edit/isEditable.js';
import '@testing-library/dom';
import '@testing-library/dom/dist/helpers.js';
import '../../utils/keyDef/readNextDescriptor.js';
import { getTreeDiff } from '../../utils/misc/getTreeDiff.js';
import '../../utils/misc/level.js';
import { assertPointerEvents, hasPointerEvents } from '../../utils/pointer/cssPointerEvents.js';
import { isDifferentPointerPosition } from './index.js';

class Pointer {
    init(config, position) {
        this.position = position;
        const target = this.getTarget(config);
        const [, enter] = getTreeDiff(null, target);
        const init = this.getEventInit();
        assertPointerEvents(config, target);
        dispatchUIEvent(config, target, 'pointerover', init);
        enter.forEach((el)=>dispatchUIEvent(config, el, 'pointerenter', init));
        return this;
    }
    move(config, position) {
        const prevPosition = this.position;
        const prevTarget = this.getTarget(config);
        this.position = position;
        if (!isDifferentPointerPosition(prevPosition, position)) {
            return;
        }
        const nextTarget = this.getTarget(config);
        const init = this.getEventInit();
        const [leave, enter] = getTreeDiff(prevTarget, nextTarget);
        return {
            leave: ()=>{
                if (hasPointerEvents(config, prevTarget)) {
                    if (prevTarget !== nextTarget) {
                        dispatchUIEvent(config, prevTarget, 'pointerout', init);
                        leave.forEach((el)=>dispatchUIEvent(config, el, 'pointerleave', init));
                    }
                }
            },
            enter: ()=>{
                assertPointerEvents(config, nextTarget);
                if (prevTarget !== nextTarget) {
                    dispatchUIEvent(config, nextTarget, 'pointerover', init);
                    enter.forEach((el)=>dispatchUIEvent(config, el, 'pointerenter', init));
                }
            },
            move: ()=>{
                dispatchUIEvent(config, nextTarget, 'pointermove', init);
            }
        };
    }
    down(config, _keyDef) {
        if (this.isDown) {
            return;
        }
        const target = this.getTarget(config);
        assertPointerEvents(config, target);
        this.isDown = true;
        this.isPrevented = !dispatchUIEvent(config, target, 'pointerdown', this.getEventInit());
    }
    up(config, _keyDef) {
        if (!this.isDown) {
            return;
        }
        const target = this.getTarget(config);
        assertPointerEvents(config, target);
        this.isDown = false;
        dispatchUIEvent(config, target, 'pointerup', this.getEventInit());
    }
    release(config) {
        const target = this.getTarget(config);
        const [leave] = getTreeDiff(target, null);
        const init = this.getEventInit();
        // Currently there is no PointerEventsCheckLevel that would
        // make this check not use the *asserted* cached value from `up`.
        /* istanbul ignore else */ if (hasPointerEvents(config, target)) {
            dispatchUIEvent(config, target, 'pointerout', init);
            leave.forEach((el)=>dispatchUIEvent(config, el, 'pointerleave', init));
        }
        this.isCancelled = true;
    }
    getTarget(config) {
        var _target;
        return (_target = this.position.target) !== null && _target !== void 0 ? _target : config.document.body;
    }
    getEventInit() {
        return {
            ...this.position.coords,
            pointerId: this.pointerId,
            pointerType: this.pointerType,
            isPrimary: this.isPrimary
        };
    }
    constructor({ pointerId , pointerType , isPrimary  }){
        this.isMultitouch = false;
        this.isCancelled = false;
        this.isDown = false;
        this.isPrevented = false;
        this.position = {};
        this.pointerId = pointerId;
        this.pointerType = pointerType;
        this.isPrimary = isPrimary;
        this.isMultitouch = !isPrimary;
    }
}

export { Pointer };
